/* 
---------------------------------------------------------
🤩.Vue是怎么操作DOM的？
在.vue文件中的模板最后会被转换成以js对象形式表达的虚拟DOM树结构，然后vue的内部为了减少更多的DOM操作，使用diff算法对比这些虚拟dom内部节点的变化，
再进行移动和更新，最后会对这些虚拟dom批量转换成真实dom显示到页面，对于列表渲染出来的元素，在书写vue代码时，vue就会提示每个列表项必须要有一个唯一的key，而且vue也不推荐使用索引来作为key，
因为在虚拟dom的对比以及更新中，需要一个稳定且唯一的值来判断当前节点的位置和内容信息，最后来决定是否需要重新patch或移动，如果经过计算后的列表项不需要任何变化，虚拟dom就不会被改变，
这样会避免不必要的dom操作

[vue的内部有一个异步更新队列，在同一个事件循环中，即使数据变化多次，DOM更新也只会执行一次。Vue会将所有的数据变更积累起来，在事件循环的下一个tick中统一处理，可以避免不必要的重渲染]
-----------------------------------------------------------

🤩.GET 和 POST 的区别？
答：首先GET请求与POST请求最明显的区别就是，
GET请求主要是向服务端请求数据(也可以发送数据,数据会被放到url中传输，不太安全，而且数据的长度也有限制)，POST请求一般是向服务器提交数据(数据会被放到body中传输，相对更安全，数据长度没限制)；
-->幂等性：GET请求具有幂等性 :即使执行多次GET请求，从服务器返回的结果都是相同的
          POST不具有幂等性(PUT具有幂等性)
-->安全性：GET方法不会修改服务器上的资源，所以是安全的
          POST会修改服务器上的资源，因此不安全
-->是否可缓存: GET方法响应可以被缓存(可以省去再次请求服务器)
              POST方法默认不可缓存 
-----------------------------------------------------------
🤩.关于重定向？
如果服务器端不返回301或302(这种状态码浏览器会自己进行跳转，前端不能控制)，可以返回一个用于重定向的url，然后前端从响应中读取到这个url，可以使用window.location.href进行跳转，如果在vue或react的框架中，可以使用各自的路由进行跳转。
------------------------------------------------------------
🤩.HTTP(响应)状态码？(🌸)
  1. 1XX:
         100 continue   表示现在的状态一切正常，客户端应该继续请求
         101 Switching Protocol   状态码表示服务器应客户端升级协议的请求正在切换协议。服务器会发送一个Upgrade响应头来表明其正在切换过去的协议。在使用 WebSockets 时会用到协议切换。
  2. 2xx:
         200 OK  请求成功(默认情况下状态码为 200 的响应可以被缓存),PUT 和 DELETE 的请求成功通常并不是200的状态码而是204,表示无内容（或者 201 Created表示一个资源首次被创建成功）。
         201 Created 请求成功，且创建了新的资源
         204 No Content 请求成功处理，但是没有内容返回(服务器不返回任何数据，但可能会返回新的或更新的元信息，比如PUT请求)，通知客户端操作成功，而不需要改变当前页面或状态
  3. 3xx:
         301 Moved Permanently 永久重定向，当网页或资源的URL永久改变时使用，使用301重定向时，搜索引擎会更新其索引来反映新的url，并将旧url的大部分链接权重和利时传递给新的url(seo友好)
         浏览器会缓存301重定向，在第一次重定向之后，如果再次访问，会直接跳转到重定向的地址
         302 Found 暂时重定向 ，搜索引擎不会更新索引来反映新的url，且浏览器不会缓存302，所以用户每次访问旧url时，浏览器都会向服务器发送请求。 
         304 Not Modified  告诉客户端不用发送请求，可以使用当前缓存。当客户端通过发送一个带有If-Nodified-Since或If-None-Match头部的HTTP请求来检查资源是否更新时，如果资源自从上次请求后就没有变化，服务器就会返回304状态码(304状态码仅适用于GET和HEAD请求)
  4. 4xx:
         400 Bad Request 服务器认为是客户端的错误，所以拒绝处理该请求
         401 Unauthorized 请求不成功，因为缺少目标资源所要求的有效身份验证凭证，服务器可能会返回这个状态码表明客户端尝试访问的资源是受保护的，而当前的请求没有提供身份验证信息或提供的验证信息不被接受。(在访问1.受保护的资源  2.身份验证机制(如JWT认证失败时) 3.会话过期(用户已经登录但会话过期的情况下))
         -->在接收到401响应后，客户端应该提示用户重新输入认证信息，或确保请求中含有有效的身份验证凭证，对于基于会话的应用，要确保用户回话没有过期，及时刷新令牌或重新登录
         403 Forbidden 客户端错误，服务端有能力处理，但是拒绝处理。
         404 Not Found 服务器无法找到所请求的资源，返回该响应的链接通常称为坏链或死链。
         410 Gone 请求的目标资源在原服务器上不存在了，并且是永久性的丢失。
  5. 5xx：
        501 Not Implemented 表示请求的方法不被服务器支持，因此无法被处理
————————————————————————————————————————————————————————————————
🤩.协商缓存与强缓存？(http缓存)(🌷)
->强缓存可以通过设置Cache-Control和Expires头实现(在服务端设置)，告诉浏览器在一定时间内，可以直接使用本地缓存的资源，而不用向服务器发送请求
 --> Cache-Control: max-age=<seconds>  max-age用于设置缓存存储的最大周期(单位是s)
 --> Cache-control: public  表明响应可以被任何对象缓存
 --> Cache-Control: privite  表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。
 --> Cache-control: no-cache  强制进行协商缓存
 --> Cache-control: no-store 禁止任何缓存策略
->强缓存过期后，浏览器会向服务器发送请求来检查资源是否更新，协商缓存通过Last-Modified/If-Modified-Since 和ETAG/If-None-Match头来实现  
 协商缓存:
 1.Last-modified：服务器先读取出文件的修改时间，然后将它赋值给响应头字段last-Modified，浏览器再次请求资源时，会发送If-Modified-Since头，包含它上次收到的Last-Modified值，然后在这之后的每次请求，都会在响应头中携带此字段，然后服务端接收到请求后会和自己现在的修改时间作比较来决定使用缓存还是返回新资源。
 2。ETag：服务器读出资源的hash值(文件指纹)，然后赋值给ETag响应头字段，下次浏览器在请求时，会自动读取出响应头中的ETag，并把它的值赋给if-none-Match请求头，服务端在接收到这个字段后，会把它的值和当前hash值比较，如果两个hash值完全一致，说明文件没有被修改，可以使用缓存(于是返回304状态码，返回空的响应体，命中协商缓存)；如果不一致，会发送一个新的ETag值。

 tip:在精确度上，ETag要比last-modified高，但性能上因为Etag会多一个计算hash的算法过程，所以last-modified性能会更好一点。
————————————————————————————————————————————————————————————————
🤩.HTML文档结构？
html，head，title，meta，body
————————————————————————————————————————————————————————————————
🤩.ES6新特性？(🌻)
  1. let和const关键字，允许声明块级作用域和常量，它们两个会让声明的变量产生暂时性死区(变量在声明前它都不可用)
  2. 箭头函数 -->箭头函数没有自己的this
             -->不能用作构造函数，没有原型，不能使用new
             -->call()，apply()，bind()方法都不能改变它的thi指向
             -->不能作为Generator函数
             -->不能使用arguments对象(rest可以)
  3.模板字符串
  4.解构赋值
  5.扩展运算符(...)
  6.类class
  7.Promise (异步编程解决方案，解决回调地狱)
  8.ES Module
  9.Iterator和Generator
  10.新的数据结构，Map，Set，WeakMap，WeakSet，Symbol(唯一值)
     -->Map类似于对象，只不过它的键可以是任意数据类型
     -->Set类似于数组，但成员的值都是唯一的(可以用于数组去重)
     -->Symbol表示唯一值，主要用途是为对象添加属性名来避免属性名冲突(也可以用来创建私有属性)，Symbol不可变
    -->WeakMap只能接受对象作为键，键示弱引用的，值可以是任意类型
    WeakMap的键是弱引用的，如果没有其他引用指向键，就会被垃圾回收机制回收，WeakMap不可枚举，没有方法可以获取所有的键或值，也没有size属性
    -->WeakSet中的对象是弱引用的。
——————————————————————————————————————————————————————————————————————————
6.Vue中的组件怎么在浏览器中展现的？
7.(错误监控组件) ？
8.Vite和Webpack的不同
9.什么是BFC？怎么触发BFC？
11.Vue2与Vue3的区别？(🌸)
  1.生命周期不同，vue3在vue2的基础上删去了beforeCreate 和created，在vue3中由setup代替，它是在渲染器遇到组件时遇到的第一个钩子
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
🤩.for...in 与 for...of的区别？  (数组不推荐使用for...in循环)
  ①for...in循环用于遍历一个对象的所有可枚举属性(包括继承来的可枚举属性)
                        ^^^^^^
  ②对数组使用for...in循环，迭代的是索引，对普通对象迭代的是key值
  ③for...of可用于任何可迭代的对象(包括字符串，set，map结构)   <---for of主要用来遍历数组元素，字符串，map，set
  ④for...of不适用于普通对象(因为普通对象不是可遍历的(可迭代的))
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
🤩.TS有一个接口A，让接口B只继承A中的a,b,c三个属性，怎么做？

假设有个接口A：
interface A{
    a:string;
    b:number;
    c:boolean;
    d:Date;  //假设不让B继承这个属性
}

接口B：
interface B extends Pick<A,'a' | 'b' | 'c'>{}
                    ^^^^^^^^^^^^^^^^^^^^^^^的作用是从A中挑选'a','b','c'这三个属性来创建一个新类型，然后B接口通过继承这个新类型
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
🤩.Vue3的生命周期？
 
  1.beforeCreate 和created在setup()函数中没有对应的钩子。因为setup函数本身就是在组件创建过程中最早被调用的
  (渲染器在遇到组件时，最早执行的就是setup)
  2.onBeforeMount() 在组件被挂载之前被调用，当这个钩子被调用时，组件已经完成了其响应式状态的设置，但还没有创建 DOM 节点。它即将首次执行 DOM 渲染过程。
  3.onMounted() 在组件挂载完成后执行，组件在以下情况下被视为已挂载：
                                           ① 其所有同步子组件都已经被挂载 (不包含异步组件或 <Suspense> 树内的组件)。
                                           ② 其自身的 DOM 树已经创建完成并插入了父容器中。注意仅当根容器在文档中时，才可以保证组件 DOM 树也在文档中。
  4.onBeforeUpdate() 在组件即将因为响应式状态变更而更新其 DOM 树之前调用。(发生在虚拟DOM打补丁之前)
  5.onUpdated() 在组件因为响应式状态变更而更新其 DOM 树之后调用。
  6.onBeforeUnmount() 在组件实例被卸载之前调用。当这个钩子被调用时，组件实例依然还保有全部的功能。这个钩子在服务器端渲染期间不会被调用。
  7.onUnmounted() 在组件实例被卸载之后调用。一个组件在以下情况下被视为已卸载：
                                           ①其所有子组件都已经被卸载。
                                           ②所有相关的响应式作用 (渲染作用以及 setup() 时创建的计算属性和侦听器) 都已经停止。
                                           ③可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。
  
  8.onErrorCaptured()   -->捕获后代组件错误的
  9.onActivated()       -->Keep-Alive内置组件中的组件被插入到dom中时调用
  10.onDeactivated()    -->Keep-Alive内置组件中的组件从dom树中被移除时
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
15.深拷贝与浅拷贝(🏵️)
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
16.导致内存泄漏有哪些因素？
  1.意外的全局变量。比如在箭头函数中的this上复制且外层没有对象，会直接赋到window上作为全局变量，或者没有使用声明关键字声明的变量
  2.定时器如果在创建之后不清除也会导致内存泄露，因为它内部引用的变量会一直的不到释放
  3.闭包，因为闭包会导致内部函数的可访问对象中包含它创建时的作用域中的变量，所以如果不正确使用闭包也会导致内存泄漏
  4.未被移除的事件监听
  5.引用已从dom中移除的元素引用
  -->解决方法：
        1.使用弱引用weakMap，setMap，使用浏览器开发者工具分析内存泄漏来源，确保dom元素被移除时，也移除对它相关的引用。
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
18.页面性能优化？
  1.减少页面的网络请求，尽量使用浏览器缓存或Http缓存，避免不必要的网络请求，或者合并文件
  2.减少页面中的DOM操作，避免浏览器触发重绘和回流
  3.对于页面首次加载不需要的资源，可以采用按需加载，或者给script标签加异步的属性，async或defer
  4.使用打包工具webpack，vite进行代码优化，可以自定义打包行为，压缩代码，减少文件大小
  5.图片可以压缩上传，并选择合适的格式。
  6.避免内存泄露情况出现。
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
19.react和vue的区别？
  1.react使用jsx语法，vue使用模板语法
  2.react是单向数据流，vue也是单向数据流，同时只用v-model支持数据双向绑定
  3.react的生态系统比较好，第三方库很多，vue相对弱一些
  4.react在组件上注重逻辑和结构结合在一起，比如说jsx语法中，我们可以将html结构和js表达式写在一起，在写代码时可以更灵活一些，而vue内部封装了很多模板语法让我们直接使用，使用起来比较方便。
  5.对于数据的变化，react可以在useEffect()钩子中定义，第二个参数接受一个数组，如果是空数组代表组件渲染完后触发一次更新函数，如果不为空数组，则依赖函数会根据数组内的响应式数据是否变化而执行，vue里面有单独定义的生命周期来定义组件从挂载到卸载的过程，也有针对于监听响应式数据的watch()和watchEffect()
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
20.UDP和TCP的区别？
21.防抖和节流怎么实现？
22.盒子水平垂直居中的方式？
23.关于Promise(🌸)
24. css animation transition transform
25.async await
26.TCP四次挥手，三次握手？
27.v-show 和v-if ？
28.Vue的双向数据绑定原理？
29.proxy的优点？
30.数组扁平化
31.react hooks
32.
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
90%(js/css)：
1.JS数据类型？
答：String,Number,Object,BigInt,Symbol,Null,Undefined,Boolean

2.怎么判断JS数据类型？
typeof , instanceof , Object.prototype.toSting.call()

typeof这种方式不能准确判断null，array和object，它们三种返回的结果都是object，而且也不能准确判断NaN， typeof NaN 会返回 Number
instanceof只能判断引用类型的数据，因为它的原理是检测实例对象的原型链上有没有构造函数的prototype属性
Object.prototype.toString.call()方法可以准确判断任何类型

3.数组方法？
Array.prototype.forEach()  返回undefined ，接受一个函数作为参数，会对数组内的每一项元素执行给定方法，不改变原数组
Array.prototype.map(),返回一个新的数组，不改变原数组，新数组的元素是原数组中元素通过给定函数执行后的结果
Array.prototype.filter(),返回一个新数组，不改变原数组，通过指定条件(为true)的元素会被添加到新数组中。
Array.prototype.push()
Array.prototype.pop()
Array.prototype.unshift()  在数组开头添加，返回值是数组的新长度
Array.prototype.shift()   在数组开头移除，返回值为删除元素的值
Array.prototype.reduce() 接受一个函数和一个初始值作为参数，函数的也有两个参数，一个是上一次执行指定函数的结果和当前值，
如果是第一次执行而且传入了初始值，这个值就是指定的值，否则就是数组的第一个元素
Array.prototype.concat() 不改变原数组，返回新数组。合并数组
Array.prototye.find() 接受函数作为参数，返回通过测试的第一个元素，没有通过就返回undefined
Array.prototye.findIndex()  返回满足测试函数的第一个索引，没有返回-1
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
4.H5的新特性？(🌸)
1.利于SEO的语义化标签
<header> <nav> <footer> <section>  <arcticle> <aside>
2.可以在网页中插入视频和音频
<vedio>,<audio>
3.画布和可缩放矢量图形
<canvas>,<svg>
4.web存储
引入localStorage和sessionStorage，indexDB
5.实时通信
WebSockets(提供在客户端和服务器之间进行全双工通信的能力) 和 WebRTC(允许网页应用进行实时视频，音频通讯和数据共享)
6.拖放API
Drag and Drop    https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API/File_drag_and_drop
7.地理定位
Geolocation API   https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation
8.跨文档消息传递
PostMessage API  (跨源通信)
9.表单控件
-->新的输入类型 email color range date等
-->placeholder
-->autocomplete,autofocus,required
10.离线应用
Application Cache(已被Service Workers取代)
Service Workers  https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
5.commonJS和ESmodule的区别 
(commonJS普遍用于服务器端，ES模块一般用在浏览器中，最新版本的NodeJs也可以用ES模块)
1.commonJS使用同步的方式导入模块，在服务器端从磁盘加载非常迅速，但在浏览器端加载新的模块会发起网络请求，等待网络传输，阻塞页面渲染
  ES模块异步加载，(利用script标签加载)
2.commonJS 输出的是对模块的浅拷贝，会运行缓存的结果，一旦输出，模块内的值就算变化也不会被影响到，除非输出的是一个函数
  ES module 是对模块的只读引用，对模块中的值赋值会报错，它不会缓存运行结果，类似于const，内部的指针指向不能改变(ES module充分考虑了静态分析的需求，可以在不执行代码的情况下分析导入导出的结果)
  (ES moudle在编译时静态解析，有利于静态分析工具进行代码优化(tree-shaking))

3.commonJS是运行时加载，而ES module的导入导出语句在js引擎解析脚本时就被确定下来了(即js引擎在执行代码前就知道了模块之间的依赖关系)

es module也支持动态导入 -->import()函数 -->按需加载

因为commonJs时运行时加载，所以在处理循环依赖时可能会有问题，因为模块很有可能在加载时不完整
而es module可以做到按照顺序依次执行循环依赖

【静态分析的优点】
Tree Shaking : 因为模块间的依赖关系在编译时就确定了，打包工具(Webpack,Rollup)可以通过静态分析识别和移除未被使用的代码，减小最终打包文件的大小
按需加载: 静态分析使实现代码分割和按需加载变得简单
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

*/
