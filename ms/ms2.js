/* 
---------------------------------------------------------
🤩.Vue是怎么操作DOM的？
在.vue文件中的模板最后会被转换成以js对象形式表达的虚拟DOM树结构，然后vue的内部为了减少更多的DOM操作，使用diff算法对比这些虚拟dom内部节点的变化，
再进行移动和更新，最后会对这些虚拟dom批量转换成真实dom显示到页面，对于列表渲染出来的元素，在书写vue代码时，vue就会提示每个列表项必须要有一个唯一的key，而且vue也不推荐使用索引来作为key，
因为在虚拟dom的对比以及更新中，需要一个稳定且唯一的值来判断当前节点的位置和内容信息，最后来决定是否需要重新patch或移动，如果经过计算后的列表项不需要任何变化，虚拟dom就不会被改变，
这样会避免不必要的dom操作

[vue的内部有一个异步更新队列，在同一个事件循环中，即使数据变化多次，DOM更新也只会执行一次。Vue会将所有的数据变更积累起来，在事件循环的下一个tick中统一处理，可以避免不必要的重渲染]
    -->为什么不建议用index作为每个虚拟dom的key值？
       -->Vue通过key来判断哪些元素是新被添加的，哪些元素可以把被复用，所以就要求这个key必须是唯一且不重复的，如果使用index作为key值，如果这个元素在变化的过程中，索引还是原来的索引，
       此时即使元素本身有了改变，但Vue会认为它没有变化，复用了原来的节点，降低更新的效率。
       另外，如果元素是输入框之类的元素，在删除任意一个前面的元素时，后边的索引都会发生改变，也会导致不必要的dom操作增加。
————————————————————————————————————————————————————————————————
🤩.HTML文档结构？
html，head，title，meta，body
——————————————————————————————————————————————————————————————————————————
6.Vue中的组件怎么在浏览器中展现的？
7.(错误监控组件) ？
8.Vite和Webpack的不同
9.什么是BFC？怎么触发BFC？
11.Vue2与Vue3的区别？(🌸)
  1.生命周期不同，vue3在vue2的基础上删去了beforeCreate 和created，在vue3中由setup代替，它是在渲染器遇到组件时遇到的第一个钩子
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
🤩.TS有一个接口A，让接口B只继承A中的a,b,c三个属性，怎么做？

假设有个接口A：
interface A{
    a:string;
    b:number;
    c:boolean;
    d:Date;  //假设不让B继承这个属性
}

接口B：
interface B extends Pick<A,'a' | 'b' | 'c'>{}
                    ^^^^^^^^^^^^^^^^^^^^^^^的作用是从A中挑选'a','b','c'这三个属性来创建一个新类型，然后B接口通过继承这个新类型
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
🤩.Vue3的生命周期？
 
  1.beforeCreate 和created在setup()函数中没有对应的钩子。因为setup函数本身就是在组件创建过程中最早被调用的
  (渲染器在遇到组件时，最早执行的就是setup)
  2.onBeforeMount() 在组件被挂载之前被调用，当这个钩子被调用时，组件已经完成了其响应式状态的设置，但还没有创建 DOM 节点。它即将首次执行 DOM 渲染过程。
  3.onMounted() 在组件挂载完成后执行，组件在以下情况下被视为已挂载：
                                           ① 其所有同步子组件都已经被挂载 (不包含异步组件或 <Suspense> 树内的组件)。
                                           ② 其自身的 DOM 树已经创建完成并插入了父容器中。注意仅当根容器在文档中时，才可以保证组件 DOM 树也在文档中。
  4.onBeforeUpdate() 在组件即将因为响应式状态变更而更新其 DOM 树之前调用。(发生在虚拟DOM打补丁之前)
  5.onUpdated() 在组件因为响应式状态变更而更新其 DOM 树之后调用。
  6.onBeforeUnmount() 在组件实例被卸载之前调用。当这个钩子被调用时，组件实例依然还保有全部的功能。这个钩子在服务器端渲染期间不会被调用。
  7.onUnmounted() 在组件实例被卸载之后调用。一个组件在以下情况下被视为已卸载：
                                           ①其所有子组件都已经被卸载。
                                           ②所有相关的响应式作用 (渲染作用以及 setup() 时创建的计算属性和侦听器) 都已经停止。
                                           ③可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。
  
  8.onErrorCaptured()   -->捕获后代组件错误的
  9.onActivated()       -->Keep-Alive内置组件中的组件被插入到dom中时调用
  10.onDeactivated()    -->Keep-Alive内置组件中的组件从dom树中被移除时
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
16.导致内存泄漏有哪些因素？
  1.意外的全局变量。比如在箭头函数中的this上复制且外层没有对象，会直接赋到window上作为全局变量，或者没有使用声明关键字声明的变量
  2.定时器如果在创建之后不清除也会导致内存泄露，因为它内部引用的变量会一直的不到释放
  3.闭包，因为闭包会导致内部函数的可访问对象中包含它创建时的作用域中的变量，所以如果不正确使用闭包也会导致内存泄漏
  4.未被移除的事件监听
  5.引用已从dom中移除的元素引用
  -->解决方法：
        1.使用弱引用weakMap，setMap，使用浏览器开发者工具分析内存泄漏来源，确保dom元素被移除时，也移除对它相关的引用。
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
18.页面性能优化？
  1.减少页面的网络请求，尽量使用浏览器缓存或Http缓存，避免不必要的网络请求，或者合并文件
  2.减少页面中的DOM操作，避免浏览器触发重绘和回流
  3.对于页面首次加载不需要的资源，可以采用按需加载，或者给script标签加异步的属性，async或defer
  4.使用打包工具webpack，vite进行代码优化，可以自定义打包行为，压缩代码，减少文件大小
  5.图片可以压缩上传，并选择合适的格式。
  6.避免内存泄露情况出现。
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
19.react和vue的区别？
  1.react使用jsx语法，vue使用模板语法
  2.react是单向数据流，vue也是单向数据流，同时只用v-model支持数据双向绑定
  3.react的生态系统比较好，第三方库很多，vue相对弱一些
  4.react在组件上注重逻辑和结构结合在一起，比如说jsx语法中，我们可以将html结构和js表达式写在一起，在写代码时可以更灵活一些，
    而vue内部封装了很多模板语法让我们直接使用，使用起来比较方便。
  5.对于数据的变化，react可以在useEffect()钩子中定义，第二个参数接受一个数组，如果是空数组代表组件渲染完后触发一次更新函数，
    如果不为空数组，则依赖函数会根据数组内的响应式数据是否变化而执行，vue里面有单独定义的生命周期来定义组件从挂载到卸载的过程，也有针对于监听响应式数据的watch()和watchEffect()
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
20.UDP和TCP的区别？
21.防抖和节流怎么实现？
  首先防抖(Debouncing),使目标函数在事件触发后的指定时间后执行，如果在此期间重复触发，会重新计时；【避免因频繁触发事件而执行不必要的操作】
  eg.
  const debounce = (func, wait) => {
  let timeout;
  return () => {
    const context = this,
      args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
};
// Use it
window.addEventListener(
  "resize",
  debounce(() => {
    console.log("我执行了");
  }, 300)
);
  节流(throttling),确保函数在一定时间间隔内只执行一次，即使事件被多次触发，函数也只是周期性执行；【保证在给定的时间内至少执行一次，适合于需要连续响应用户操作的场景】
  // 节流：(在指定的时间间隔内最多只执行一次)
const throttling = (fn, limit) => {
  let inThrottle;  //标志变量，用于记录是否在冷却时间；
  return function () {  //返回一个新函数，封装了原始的fn函数，控制它的执行频率
    const context = this,
      args = arguments;
    if (!inThrottle) { //为false
      fn.apply(context, args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
};

window.addEventListener(
  "scroll",
  throttling(() => {
    console.log("我执行了"), 300;
  })
);


22.盒子水平垂直居中的方式？
23.关于Promise(🌸)
24. css animation transition transform
25.async await
26.TCP四次挥手，三次握手？
27.v-show 和v-if ？
————————————————————————————————————————————————————————————————————————————————————————————————————————————————
28.Vue的双向数据绑定原理？
vue3的双向绑定主要依赖于v-model指令，以及vue的响应式系统实现的
                      ^^^^^^^^^^^      ^^^^^^^^^^^^^
首先：
Vue的响应式系统:vue2是使用Object.defineProperty()方法来实现的，它的缺陷是只能拦截某个对象的某个属性，监听过程中会深度遍历所有这个对象的属性值，
这种方法，如果直接去修改对象的属性(比如添加或删除属性)，(通过数组索引以及数组长度额度改变)并不能检测到.
   --->Vue提供了全局方法来解决:Vue.set()或this.$set
                        ---->用于向响应式对象中添加一个属性，并确保这个新属性石也是响应式的
                        语法：Vue.set(target,propertyName/index,value) 或 this.$set(target,propertyName/index,value)
                          ->target可以是数组或普通对象
                          propertyName/index是要添加的属性名或数组的索引，value是属性的值
                      Vue.delete 或this.$delete [删除]
Vue3使用proxy，它的优点是可以直接拦截整个对象(在不需要递归遍历的情况下实现响应式)
它的思路是拦截一个对象的getter和setter操作，通过WeakMap与Map以及Set这些数据结构，共同维护了一个在代理对象与所要操作的属性，
以及对这个属性要执行的副作用函数(Effect)之间的关系，核心是把对数据的读取或修改操作都变成一个函数来执行，当读取对象的属性时，
就会收集当前的副作用函数到一个effectStack中，修改时从栈中弹出，查找所有这个属性的所依赖的副作用函数并执行，
拦截器的内部使用Reflect上的方法，它的优点在于可以接受第三个参数，相当于一个this，代表是谁在操作
(tip:副作用函数指的是一个执行会直接或间接影响其他函数执行的函数)
---------->Reflect:
              -->Reflect是一个内置对象，它提供拦截 JavaScript 操作的方法(出自MDN)，Reflect提供的方法与Proxy的方法相对应，它让Object操作都变成函数行为
              Reflect.get(target,propertyKey,[receiver])  第一个参数是目标对象 ; 第二个参数 是要获取的属性名称 ; 
              第三个是可选参数，如果目标属性是一个getter函数，那么receiver会作为getter调用时的this值
              Reflect.set()同理...
 
Vue创建响应式对象主要是用reactive创建的，他针对于对象类型的数据，因为JavaScript中一切都是对象，
所以不管是对数组还是Set，Map这些数据结构进行任何操作，本质上也是对对象的读取和修改，只是拦截方法不同
-->对于原始值的响应式方案，Vue提供了ref，主要用来让基本数据类型变成响应式数据的，因为proxy只支持代理对象，所以ref内部把所有的基本数据类型外部都包裹了一层对象，
并额外地给它添加了一个属性来标识它是一个ref，以便之后在setup的返回值和模板中脱掉ref。
-->ref解决了响应式丢失的的问题，响应式丢失就是如果我们用reactive来创建一个响应式的对象，然后再把它其中的属性赋值给另外一个普通对象中，
这样响应式就会丢失，因为它不再是原来的对象了，就算属性都是一样的。
在ref中解决了这个问题，因为ref会首先被一个对象包裹，它的属性和与响应式属性同名，值就是getter和setter操作。
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————
29.proxy的优点？
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
32.进程和线程的区别和联系？
(可以说进程是包含线程的，即线程是进程的子集)
进程： 是运行在系统内存中的程序，每个进程都有自己单独的地址空间
【资源分配的基本单位】
【进程间相互独立，一个进程崩溃后，在保护模式下不会对其他进产生影响】
线程：线程是程序执行的最小单元，它没有自己的地址空间，它可以与同属与一个进程中的其他线程共享进程中的所有资源
【CPU调度的基本单位】
【线程间资源共享，一个线程崩溃可能会影响到同一进程中的其他线程】

--->一个进程可以包含一个或多个线程。
—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
33.进程之间的通信有哪些？
IPC：操作系统的消息，信号，管道，共享内存等机制

--->锁：
在多线程环境下，为了防止不同线程在并发访问共享资源时产生数据不一致的问题，需要使用一种机制来确保任一时刻只有一个线程可以访问特定的资源或代码块(锁)
当一个线程锁定某个资源时，其他试图访问该资源的线程将会被阻塞，直到锁被释放为止。
锁的类型：
1.互斥锁(Mutex):确保同一时刻只有一个线程可以访问共享资源
2.读写锁(ReadWriteLock)：允许多个读操作同时进行，但写操作互斥
3.自旋锁(Soinlock):线程反复检查锁是否可用，而不是等待时睡眠
4.死锁，饥饿...
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
34.为什么浏览器是多进程的？

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
3.OSI七层模型？
答：
    1.物理层 (电缆，光纤)
    2.数据链路层 (在相邻的节点间建立，维护和终止链路连接)
    3.网络层 (负责设备间的数据传输和路由选择，确保数据包能够从源头到达目的地 IP)
    4.传输层 (提供端到端的数据传输服务，确保数据的完整性和顺序，两个协议：TCP/UDP)
    5.会话层 (负责在网络中的两节点之间建立，管理和终止会话，会话可以被视为不同进程间的对话或数据交换会话，会话层确保会话能够无错误地进行)
    6.表示层 (确保一个系统发送的信息能够被另一个系统读取和理解，关注的是数据的格式化，编码和解码，以及数据的压缩和解压缩)
    7.应用层 (直接为应用程序提供服务，定义了很多标准的鼓舞和协议，比如HTTP协议，FTP(文件传输),SMTP(电子邮件传输),应用层使用户能够接入网络服务)
——————————————————————————————————————————————————————————————————————————————————————————————————————
4.TCP/IP四层模型？ (互联网协议套件)
    4.应用层 (HTTP)
    3.传输层 (TCP/IP)
    2.网际层 (主要负责在多个网络之间传输数据，其核心协议使互联网协议(IP),它负责数据包的寻址和路由，确保数据包能够跨越多个网络从源头传输到目的地)
    1.网络接口层 (相当于OSI模型的物理层和数据链路层，负责与物理网络硬件进行交互，并处理在网络设备之间传输数据包的细节)
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
5.网络五层模型？
    5.应用层
    4.传输层
    3.网络层
    2.数据链路层
    1.物理层

——————————————————————————————————————————————————————————————————————————————————————————
4.怎么比较浮点数？
——————————————————————————————————————————————————————————————————————————————————————————————
call(),apply(),bind()?
  首先他们三个都用来设置函数内部this值，可以为函数调用指定一个具体的对象作为上下文(this);
  1. call()
  语法： func.call(thisArg,arg1,arg2...);
  参数说明：thisArg，在func函数运行时使用的this值
          arg1，arg2，传递给函数的参数列表
  2. apply()
  语法：func.apply(thisArg,[argsArray]);
  参数说明： argsArray 一个数组或类数组对象
  3. bind()
  创建一个新的函数，bind()被调用时，新函数的this被指定为bind()的第一个参数，其余函数作为新函数的参数

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
————————————————————————————————————
10.什么是死锁？
11.怎么解决死锁？

12.http 1.0/1.1/2.0/3.0各解决了什么问题？


13.flex有哪些属性？
14.敏感词过滤
15.快速排序
16.非关系型数据库有什么？
17.数据库左连接，右连接区别？
18.vue和react分别是怎么解决样式污染的？
19.TS中的any 和unknown区别？
20.react的useState定义的状态如何确保能拿到最新的值？
——————————————————————————————————————————————————————————————————————————————————————
21.flex：1 的含义？
答：首先，flex属性时flex-grow,flex-shrink,flex-basis的简写，默认值为0 1 auto

flex-grow：元素在 flex 容器中分配剩余空间的相对比例
flex-shrink：指定了 flex 元素的收缩规则
flex-basis：指定了 flex 元素在主轴方向上的初始大小
——————————————————————————————————————————————————————————————————————————————————————
22.vue-router两种路由实现方式？
23.React中父组件如何调用子组件的方法？
24.如何定义组件的状态信息(useState()),如果在某个方法中调用了setState改变状态，setState中能获取到最新的值吗？
25.webSocket的心跳检测与重连机制？
26.编写一个executeTasks函数，它接受一个异步任务数组作为参数，每个任务是一个会返回Promise的函数，目的是同时启动这些异步任务，并且在每个任务完成时，
立即按照它们在数组中的原始顺序显示它们的结果？

// Promise.all可以同时启动多个异步任务  map可以确保它们按照原始的顺序执行
// 但是：Promise.all实在所有任务都完成之后才会返回，所以可以使用Promise.allsettled(或为每个任务单独处理)

Promise.all与Promise.allSettled的区别：
1.当传递给Promise.all的所有promise都成功解决(fullfilled)时,它返回一个promise，这个promise是一个包含所有promise返回的值的数组，如果传递给promise.all的任意一个promise失败，它就会立即返回reject
2.不管传递给Promise.allSettled的Promise是reject还是resolve，它都会等待所有的promise都完成，返回一个数组，数组里是对象

const executeTasks = (tasks)=>{
  const promise = tasks.map( task => task());
  promise.allSettled(promise).then(results=>{
    results.forEach((result,index)=>{
      console.log(result);
    })
  })
}

TS泛型：
指的是在定义函数，接口或类时不具体指定的数据类型，而是在使用时指定类型。
基本用法：
function identify<T>(arg:T):T{  //identify函数接受任何类型T的参数arg，并直接返回这个参数，返回的类型也是类型T
  return arg;
}

TS接口(interface):用于定义对象结构，接口可以定义一个规范，对象必须遵循这个规范，这些规范可以包括属性的存在，类型，以及方法的签名

27.哪些情况下Cookie可以共享？
   1.相同域名之间的Cookie可以共享 
   ----> 比如：www.dks.com 和 app.example.com
   2.父域和子域之间
   ---->子域可以设置自己的Cookie，但父域不能访问子域设置的Cookie，除非子域在设置Cookie时，明确指定了父域为Cookie的域名
  .....
28.原型以及原型链？
JavaScript函数在创建时，会自动获得一个prototype属性，它指向原型对象，通过这个函数创建出的实例对象同样也有一个__proto__属性关联着这个原型，
而且它在所有实例之间相互共享，prototype身上会有一个consructor属性指回构造函数

原型链是机制，也可以实现继承，如果访问一个对象本身的属性或方法发现不存在时，会自动去它的原型上去寻找，如果原型上也不存在，会一次查找原型的原型，直到遇到null(原型的末端)

 https://vue3js.cn/interview/JavaScript/closure.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88
29.闭包？
(闭包产生于函数创建时)一个js函数创建时，会把它创建时所在的作用域中的可访问变量添加到自己的活动变量中，然后即使这些外部变量(执行上下文被销毁)被销毁了，也仍然可以被闭包函数访问到
   ---应用场景：
              1.创建私有变量 : 在JavaScript中使用闭包可以模拟私有变量的功能，使得这些变量不会被外界直接访问
                   --> 私有变量：指的是只能在定义它们的类或函数内部访问的变量，而不能从外部直接访问
                           function Person(name){
                            let _name = name;
                            this.getName = function(){
                              return _name;
                            }
                           }
                           const person = new Person("KyungSoo");
                           console.log(person.getName())  //"KyungSoo"
                          // 变量定义在一个函数内部，只有这个函数的其他函数可以访问到它
                          // ES6之前，使用闭包可以实现私有变量，ES6之后，可使用class关键字定义类，并利用新的私有字段特性来创建私有变量，私有字段名以 # 开头
              2.延长变量生命周期   
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
30. css原子化和预编译？
--> css原子化是一种CSS架构方法，是使用一组单一用途的类来构建页面。每个类对应特定的样式属性和值。目的是在不同的HTML元素上可以重用这些类。
特点：
    1.高复用性(可以在任何元素上复用)
    2.可维护性
    3.减少代码量
.eg:
   .p-4{
    padding:1rem;
   }
   .mt-2{
    margin-top:0.5rem;
   }
   .text-center{
    text-align:center;
   }
   .bg-red{
    background-color:red;
   }
  //  HTML中：
  <button class="p-4 mt-2 text-center bg-red"></button>
  框架：Tailwind CSS
  缺点：HTML变得冗长，由于类名的增多,可能影响可读性
--> css 用于增强传统CSS的功能和可维护性，可以使用变量，函数，嵌套规则等高级功能来编写样式，然后将这些代码预编译成标准的CSS文件，以便在浏览器中使用
  【就是Sass，less，stylus预编译】
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
31.文件上传可以做的优化？如何实现？
   文件分片上传(断点续传)、压缩上传
   FormData是JS中的一个内建对象，用于构建一组键值对，代表表单字段和值
   1.构造FormData对象：
      直接从<form>元素构造，自动将表单中的数据转换为FormData对象；
      -->添加数据：
      使用append()方法可以添加数据到FormData对象中，append方法可以接收Blob类型的数据，包括文件内容
      const fileInput = document.querySelector('input[type="file"]');
      formData.append("file",fileInput.files[0]);
      -->发送数据：
      fetch('xxx',{
        method:"POST",
        body:formData  //当使用FormData与FetchAPI结合发送数据时，不需要设置Content-Type头部，浏览器会自动设置正确地Content-Type
      })
      FormData的优点：可以简化文件上传，不需要手动处理文件编码，直接将文件附件添加到表单数据中 
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
32.对前端工程化的理解？
33.怎么实现一个vite插件？
   插件配置：https://cn.vitejs.dev/guide/api-plugin.html#plugins-config
   roullup插件：https://cn.rollupjs.org/plugin-development/#plugins-overview
   首先，Vite插件可以利用一系列钩子来介入应用的构建过程：
      1.config 用于修改Vite配置
      2.configureServer 用于配置开发服务器
      3.transform 用于转换已加载的模块
      4.resolved 自定义解析逻辑
      5.load 自定义加载逻辑

34.




*/
