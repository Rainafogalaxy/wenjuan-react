/* 
---------------------------------------------------------

————————————————————————————————————————————————————————————————
🤩.HTML文档结构？
html，head，title，meta，body
——————————————————————————————————————————————————————————————————————————
6.Vue中的组件怎么在浏览器中展现的？
11.Vue2与Vue3的区别？(🌸)
  1.生命周期不同，vue3在vue2的基础上删去了beforeCreate 和created，在vue3中由setup代替，它是在渲染器遇到组件时遇到的第一个钩子
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
16.导致内存泄漏有哪些因素？
  1.意外的全局变量。比如在箭头函数中的this上复制且外层没有对象，会直接赋到window上作为全局变量，或者没有使用声明关键字声明的变量
  2.定时器如果在创建之后不清除也会导致内存泄露，因为它内部引用的变量会一直的不到释放
  3.闭包，因为闭包会导致内部函数的可访问对象中包含它创建时的作用域中的变量，所以如果不正确使用闭包也会导致内存泄漏
  4.未被移除的事件监听
  5.引用已从dom中移除的元素引用
  -->解决方法：
        1.使用弱引用weakMap，setMap，使用浏览器开发者工具分析内存泄漏来源，确保dom元素被移除时，也移除对它相关的引用。
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
18.页面性能优化？
  1.减少页面的网络请求，尽量使用浏览器缓存或Http缓存，避免不必要的网络请求，或者合并文件
  2.减少页面中的DOM操作，避免浏览器触发重绘和回流
  3.对于页面首次加载不需要的资源，可以采用按需加载，或者给script标签加异步的属性，async或defer
  4.使用打包工具webpack，vite进行代码优化，可以自定义打包行为，压缩代码，减少文件大小
  5.图片可以压缩上传，并选择合适的格式。
  6.避免内存泄露情况出现。
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
19.react和vue的区别？
  1.react使用jsx语法，vue使用模板语法
  2.react是单向数据流，vue也是单向数据流，同时只用v-model支持数据双向绑定
  3.react的生态系统比较好，第三方库很多，vue相对弱一些
  4.react在组件上注重逻辑和结构结合在一起，比如说jsx语法中，我们可以将html结构和js表达式写在一起，在写代码时可以更灵活一些，
    而vue内部封装了很多模板语法让我们直接使用，使用起来比较方便。
  5.对于数据的变化，react可以在useEffect()钩子中定义，第二个参数接受一个数组，如果是空数组代表组件渲染完后触发一次更新函数，
    如果不为空数组，则依赖函数会根据数组内的响应式数据是否变化而执行，vue里面有单独定义的生命周期来定义组件从挂载到卸载的过程，也有针对于监听响应式数据的watch()和watchEffect()
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————


—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
33.进程之间的通信有哪些？
IPC：操作系统的消息，信号，管道，共享内存等机制

--->锁：
在多线程环境下，为了防止不同线程在并发访问共享资源时产生数据不一致的问题，需要使用一种机制来确保任一时刻只有一个线程可以访问特定的资源或代码块(锁)
当一个线程锁定某个资源时，其他试图访问该资源的线程将会被阻塞，直到锁被释放为止。
锁的类型：
1.互斥锁(Mutex):确保同一时刻只有一个线程可以访问共享资源
2.读写锁(ReadWriteLock)：允许多个读操作同时进行，但写操作互斥
3.自旋锁(Soinlock):线程反复检查锁是否可用，而不是等待时睡眠
4.死锁，饥饿...
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
34.为什么浏览器是多进程的？
——————————————————————————————————————————————————————————————————————————————————————————
4.怎么比较浮点数？
——————————————————————————————————————————————————————————————————————————————————————————————

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
————————————————————————————————————
10.什么是死锁？
11.怎么解决死锁？

12.http 1.0/1.1/2.0/3.0各解决了什么问题？


13.flex有哪些属性？
14.敏感词过滤
15.快速排序

17.数据库左连接，右连接区别？
18.vue和react分别是怎么解决样式污染的？
19.TS中的any 和unknown区别？
20.react的useState定义的状态如何确保能拿到最新的值？
——————————————————————————————————————————————————————————————————————————————————————
22.vue-router两种路由实现方式？

24.如何定义组件的状态信息(useState()),如果在某个方法中调用了setState改变状态，setState中能获取到最新的值吗？
25.webSocket的心跳检测与重连机制？
26.编写一个executeTasks函数，它接受一个异步任务数组作为参数，每个任务是一个会返回Promise的函数，目的是同时启动这些异步任务，并且在每个任务完成时，
立即按照它们在数组中的原始顺序显示它们的结果？

// Promise.all可以同时启动多个异步任务  map可以确保它们按照原始的顺序执行
// 但是：Promise.all实在所有任务都完成之后才会返回，所以可以使用Promise.allsettled(或为每个任务单独处理)

Promise.all与Promise.allSettled的区别：
1.当传递给Promise.all的所有promise都成功解决(fullfilled)时,它返回一个promise，这个promise是一个包含所有promise返回的值的数组，如果传递给promise.all的任意一个promise失败，它就会立即返回reject
2.不管传递给Promise.allSettled的Promise是reject还是resolve，它都会等待所有的promise都完成，返回一个数组，数组里是对象

const executeTasks = (tasks)=>{
  const promise = tasks.map( task => task());
  promise.allSettled(promise).then(results=>{
    results.forEach((result,index)=>{
      console.log(result);
    })
  })
}

TS泛型：
指的是在定义函数，接口或类时不具体指定的数据类型，而是在使用时指定类型。
基本用法：
function identify<T>(arg:T):T{  //identify函数接受任何类型T的参数arg，并直接返回这个参数，返回的类型也是类型T
  return arg;
}

TS接口(interface):用于定义对象结构，接口可以定义一个规范，对象必须遵循这个规范，这些规范可以包括属性的存在，类型，以及方法的签名

27.哪些情况下Cookie可以共享？
   1.相同域名之间的Cookie可以共享 
   ----> 比如：www.dks.com 和 app.example.com
   2.父域和子域之间
   ---->子域可以设置自己的Cookie，但父域不能访问子域设置的Cookie，除非子域在设置Cookie时，明确指定了父域为Cookie的域名
  .....
28.原型以及原型链？
JavaScript函数在创建时，会自动获得一个prototype属性，它指向原型对象，通过这个函数创建出的实例对象同样也有一个__proto__属性关联着这个原型，
而且它在所有实例之间相互共享，prototype身上会有一个consructor属性指回构造函数

原型链是机制，也可以实现继承，如果访问一个对象本身的属性或方法发现不存在时，会自动去它的原型上去寻找，如果原型上也不存在，会一次查找原型的原型，直到遇到null(原型的末端)

 https://vue3js.cn/interview/JavaScript/closure.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88
29.闭包？
(闭包产生于函数创建时)一个js函数创建时，会把它创建时所在的作用域中的可访问变量添加到自己的活动变量中，然后即使这些外部变量(执行上下文被销毁)被销毁了，也仍然可以被闭包函数访问到
   ---应用场景：
              1.创建私有变量 : 在JavaScript中使用闭包可以模拟私有变量的功能，使得这些变量不会被外界直接访问
                   --> 私有变量：指的是只能在定义它们的类或函数内部访问的变量，而不能从外部直接访问
                           function Person(name){
                            let _name = name;
                            this.getName = function(){
                              return _name;
                            }
                           }
                           const person = new Person("KyungSoo");
                           console.log(person.getName())  //"KyungSoo"
                          // 变量定义在一个函数内部，只有这个函数的其他函数可以访问到它
                          // ES6之前，使用闭包可以实现私有变量，ES6之后，可使用class关键字定义类，并利用新的私有字段特性来创建私有变量，私有字段名以 # 开头
              2.延长变量生命周期   
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
30. css原子化和预编译？
--> css原子化是一种CSS架构方法，是使用一组单一用途的类来构建页面。每个类对应特定的样式属性和值。目的是在不同的HTML元素上可以重用这些类。
特点：
    1.高复用性(可以在任何元素上复用)
    2.可维护性
    3.减少代码量
.eg:
   .p-4{
    padding:1rem;
   }
   .mt-2{
    margin-top:0.5rem;
   }
   .text-center{
    text-align:center;
   }
   .bg-red{
    background-color:red;
   }
  //  HTML中：
  <button class="p-4 mt-2 text-center bg-red"></button>
  框架：Tailwind CSS
  缺点：HTML变得冗长，由于类名的增多,可能影响可读性
--> css 用于增强传统CSS的功能和可维护性，可以使用变量，函数，嵌套规则等高级功能来编写样式，然后将这些代码预编译成标准的CSS文件，以便在浏览器中使用
  【就是Sass，less，stylus预编译】
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
31.文件上传可以做的优化？如何实现？
   文件分片上传(断点续传)、压缩上传
   FormData是JS中的一个内建对象，用于构建一组键值对，代表表单字段和值
   1.构造FormData对象：
      直接从<form>元素构造，自动将表单中的数据转换为FormData对象；
      -->添加数据：
      使用append()方法可以添加数据到FormData对象中，append方法可以接收Blob类型的数据，包括文件内容
      const fileInput = document.querySelector('input[type="file"]');
      formData.append("file",fileInput.files[0]);
      -->发送数据：
      fetch('xxx',{
        method:"POST",
        body:formData  //当使用FormData与FetchAPI结合发送数据时，不需要设置Content-Type头部，浏览器会自动设置正确地Content-Type
      })
      FormData的优点：可以简化文件上传，不需要手动处理文件编码，直接将文件附件添加到表单数据中 
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
32.对前端工程化的理解？
33.怎么实现一个vite插件？
   插件配置：https://cn.vitejs.dev/guide/api-plugin.html#plugins-config
   roullup插件：https://cn.rollupjs.org/plugin-development/#plugins-overview
   首先，Vite插件可以利用一系列钩子来介入应用的构建过程：
      1.config 用于修改Vite配置
      2.configureServer 用于配置开发服务器
      3.transform 用于转换已加载的模块
      4.resolved 自定义解析逻辑
      5.load 自定义加载逻辑

34.




*/
