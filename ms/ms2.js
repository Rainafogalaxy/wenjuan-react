/* 
---------------------------------------------------------
🤩.Vue是怎么操作DOM的？
在.vue文件中的模板最后会被转换成以js对象形式表达的虚拟DOM树结构，然后vue的内部为了减少更多的DOM操作，使用diff算法对比这些虚拟dom内部节点的变化，
再进行移动和更新，最后会对这些虚拟dom批量转换成真实dom显示到页面，对于列表渲染出来的元素，在书写vue代码时，vue就会提示每个列表项必须要有一个唯一的key，而且vue也不推荐使用索引来作为key，
因为在虚拟dom的对比以及更新中，需要一个稳定且唯一的值来判断当前节点的位置和内容信息，最后来决定是否需要重新patch或移动，如果经过计算后的列表项不需要任何变化，虚拟dom就不会被改变，
这样会避免不必要的dom操作

[vue的内部有一个异步更新队列，在同一个事件循环中，即使数据变化多次，DOM更新也只会执行一次。Vue会将所有的数据变更积累起来，在事件循环的下一个tick中统一处理，可以避免不必要的重渲染]
-----------------------------------------------------------

🤩.GET 和 POST 的区别？
答：首先GET请求与POST请求最明显的区别就是，
GET请求主要是向服务端请求数据(也可以发送数据,数据会被放到url中传输，不太安全，而且数据的长度也有限制)，POST请求一般是向服务器提交数据(数据会被放到body中传输，相对更安全，数据长度没限制)；
-->幂等性：GET请求具有幂等性 :即使执行多次GET请求，从服务器返回的结果都是相同的
          POST不具有幂等性(PUT具有幂等性)
-->安全性：GET方法不会修改服务器上的资源，所以是安全的
          POST会修改服务器上的资源，因此不安全
-->是否可缓存: GET方法响应可以被缓存(可以省去再次请求服务器)
              POST方法默认不可缓存 
-----------------------------------------------------------
🤩.关于重定向？
如果服务器端不返回301或302(这种状态码浏览器会自己进行跳转，前端不能控制)，可以返回一个用于重定向的url，然后前端从响应中读取到这个url，可以使用window.location.href进行跳转，如果在vue或react的框架中，可以使用各自的路由进行跳转。
------------------------------------------------------------
🤩.HTTP(响应)状态码？(🌸)
  1. 1XX:
         100 continue   表示现在的状态一切正常，客户端应该继续请求
         101 Switching Protocol   状态码表示服务器应客户端升级协议的请求正在切换协议。服务器会发送一个Upgrade响应头来表明其正在切换过去的协议。在使用 WebSockets 时会用到协议切换。
  2. 2xx:
         200 OK  请求成功(默认情况下状态码为 200 的响应可以被缓存),PUT 和 DELETE 的请求成功通常并不是200的状态码而是204,表示无内容（或者 201 Created表示一个资源首次被创建成功）。
         201 Created 请求成功，且创建了新的资源
         204 No Content 请求成功处理，但是没有内容返回(服务器不返回任何数据，但可能会返回新的或更新的元信息，比如PUT请求)，通知客户端操作成功，而不需要改变当前页面或状态
  3. 3xx:
         301 Moved Permanently 永久重定向，当网页或资源的URL永久改变时使用，使用301重定向时，搜索引擎会更新其索引来反映新的url，并将旧url的大部分链接权重和利时传递给新的url(seo友好)
         浏览器会缓存301重定向，在第一次重定向之后，如果再次访问，会直接跳转到重定向的地址
         302 Found 暂时重定向 ，搜索引擎不会更新索引来反映新的url，且浏览器不会缓存302，所以用户每次访问旧url时，浏览器都会向服务器发送请求。 
         304 Not Modified  告诉客户端不用发送请求，可以使用当前缓存。当客户端通过发送一个带有If-Nodified-Since或If-None-Match头部的HTTP请求来检查资源是否更新时，如果资源自从上次请求后就没有变化，服务器就会返回304状态码(304状态码仅适用于GET和HEAD请求)
  4. 4xx:
         400 Bad Request 服务器认为是客户端的错误，所以拒绝处理该请求
         401 Unauthorized 请求不成功，因为缺少目标资源所要求的有效身份验证凭证，服务器可能会返回这个状态码表明客户端尝试访问的资源是受保护的，而当前的请求没有提供身份验证信息或提供的验证信息不被接受。(在访问1.受保护的资源  2.身份验证机制(如JWT认证失败时) 3.会话过期(用户已经登录但会话过期的情况下))
         -->在接收到401响应后，客户端应该提示用户重新输入认证信息，或确保请求中含有有效的身份验证凭证，对于基于会话的应用，要确保用户回话没有过期，及时刷新令牌或重新登录
         403 Forbidden 客户端错误，服务端有能力处理，但是拒绝处理。
         404 Not Found 服务器无法找到所请求的资源，返回该响应的链接通常称为坏链或死链。
         410 Gone 请求的目标资源在原服务器上不存在了，并且是永久性的丢失。
  5. 5xx：
        501 Not Implemented 表示请求的方法不被服务器支持，因此无法被处理
————————————————————————————————————————————————————————————————
🤩.协商缓存与强缓存？(http缓存)(🌷)
->强缓存可以通过设置Cache-Control和Expires头实现(在服务端设置)，告诉浏览器在一定时间内，可以直接使用本地缓存的资源，而不用向服务器发送请求
 --> Cache-Control: max-age=<seconds>  max-age用于设置缓存存储的最大周期(单位是s)
 --> Cache-control: public  表明响应可以被任何对象缓存
 --> Cache-Control: privite  表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。
 --> Cache-control: no-cache  强制进行协商缓存
 --> Cache-control: no-store 禁止任何缓存策略
->强缓存过期后，浏览器会向服务器发送请求来检查资源是否更新，协商缓存通过Last-Modified/If-Modified-Since 和ETAG/If-None-Match头来实现  
 协商缓存:
 1.Last-modified：服务器先读取出文件的修改时间，然后将它赋值给响应头字段last-Modified，浏览器再次请求资源时，会发送If-Modified-Since头，包含它上次收到的Last-Modified值，然后在这之后的每次请求，都会在响应头中携带此字段，然后服务端接收到请求后会和自己现在的修改时间作比较来决定使用缓存还是返回新资源。
 2。ETag：服务器读出资源的hash值(文件指纹)，然后赋值给ETag响应头字段，下次浏览器在请求时，会自动读取出响应头中的ETag，并把它的值赋给if-none-Match请求头，服务端在接收到这个字段后，会把它的值和当前hash值比较，如果两个hash值完全一致，说明文件没有被修改，可以使用缓存(于是返回304状态码，返回空的响应体，命中协商缓存)；如果不一致，会发送一个新的ETag值。

 tip:在精确度上，ETag要比last-modified高，但性能上因为Etag会多一个计算hash的算法过程，所以last-modified性能会更好一点。
————————————————————————————————————————————————————————————————
🤩.HTML文档结构？
html，head，title，meta，body
————————————————————————————————————————————————————————————————
🤩.ES6新特性？(🌻)
  1. let和const关键字，允许声明块级作用域和常量，它们两个会让声明的变量产生暂时性死区(变量在声明前它都不可用)
  2. 箭头函数 -->箭头函数没有自己的this
             -->不能用作构造函数，没有原型，不能使用new
             -->call()，apply()，bind()方法都不能改变它的thi指向
             -->不能作为Generator函数
             -->不能使用arguments对象(rest可以)
  3.模板字符串
  4.解构赋值
  5.扩展运算符(...)
  6.类class
  7.Promise (异步编程解决方案，解决回调地狱)
  8.ES Module
  9.Iterator和Generator
  10.新的数据结构，Map，Set，WeakMap，WeakSet，Symbol(唯一值)
     -->Map类似于对象，只不过它的键可以是任意数据类型
     -->Set类似于数组，但成员的值都是唯一的(可以用于数组去重)
     -->Symbol表示唯一值，主要用途是为对象添加属性名来避免属性名冲突(也可以用来创建私有属性)，Symbol不可变
    -->WeakMap只能接受对象作为键，键示弱引用的，值可以是任意类型
    WeakMap的键是弱引用的，如果没有其他引用指向键，就会被垃圾回收机制回收，WeakMap不可枚举，没有方法可以获取所有的键或值，也没有size属性
    -->WeakSet中的对象是弱引用的。
——————————————————————————————————————————————————————————————————————————
6.Vue中的组件怎么在浏览器中展现的？
7.(错误监控组件) ？
8.Vite和Webpack的不同
9.什么是BFC？怎么触发BFC？
11.Vue2与Vue3的区别？(🌸)
  1.生命周期不同，vue3在vue2的基础上删去了beforeCreate 和created，在vue3中由setup代替，它是在渲染器遇到组件时遇到的第一个钩子
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
🤩.for...in 与 for...of的区别？  (数组不推荐使用for...in循环)
  ①for...in循环用于遍历一个对象的所有可枚举属性(包括继承来的可枚举属性)
                        ^^^^^^
  ②对数组使用for...in循环，迭代的是索引，对普通对象迭代的是key值
  ③for...of可用于任何可迭代的对象(包括字符串，set，map结构)   <---for of主要用来遍历数组元素，字符串，map，set
  ④for...of不适用于普通对象(因为普通对象不是可遍历的(可迭代的))
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
🤩.TS有一个接口A，让接口B只继承A中的a,b,c三个属性，怎么做？

假设有个接口A：
interface A{
    a:string;
    b:number;
    c:boolean;
    d:Date;  //假设不让B继承这个属性
}

接口B：
interface B extends Pick<A,'a' | 'b' | 'c'>{}
                    ^^^^^^^^^^^^^^^^^^^^^^^的作用是从A中挑选'a','b','c'这三个属性来创建一个新类型，然后B接口通过继承这个新类型
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
🤩.Vue3的生命周期？
 
  1.beforeCreate 和created在setup()函数中没有对应的钩子。因为setup函数本身就是在组件创建过程中最早被调用的
  (渲染器在遇到组件时，最早执行的就是setup)
  2.onBeforeMount() 在组件被挂载之前被调用，当这个钩子被调用时，组件已经完成了其响应式状态的设置，但还没有创建 DOM 节点。它即将首次执行 DOM 渲染过程。
  3.onMounted() 在组件挂载完成后执行，组件在以下情况下被视为已挂载：
                                           ① 其所有同步子组件都已经被挂载 (不包含异步组件或 <Suspense> 树内的组件)。
                                           ② 其自身的 DOM 树已经创建完成并插入了父容器中。注意仅当根容器在文档中时，才可以保证组件 DOM 树也在文档中。
  4.onBeforeUpdate() 在组件即将因为响应式状态变更而更新其 DOM 树之前调用。(发生在虚拟DOM打补丁之前)
  5.onUpdated() 在组件因为响应式状态变更而更新其 DOM 树之后调用。
  6.onBeforeUnmount() 在组件实例被卸载之前调用。当这个钩子被调用时，组件实例依然还保有全部的功能。这个钩子在服务器端渲染期间不会被调用。
  7.onUnmounted() 在组件实例被卸载之后调用。一个组件在以下情况下被视为已卸载：
                                           ①其所有子组件都已经被卸载。
                                           ②所有相关的响应式作用 (渲染作用以及 setup() 时创建的计算属性和侦听器) 都已经停止。
                                           ③可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。
  
  8.onErrorCaptured()   -->捕获后代组件错误的
  9.onActivated()       -->Keep-Alive内置组件中的组件被插入到dom中时调用
  10.onDeactivated()    -->Keep-Alive内置组件中的组件从dom树中被移除时
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
15.深拷贝与浅拷贝(🏵️)
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
16.导致内存泄漏有哪些因素？
  1.意外的全局变量。比如在箭头函数中的this上复制且外层没有对象，会直接赋到window上作为全局变量，或者没有使用声明关键字声明的变量
  2.定时器如果在创建之后不清除也会导致内存泄露，因为它内部引用的变量会一直的不到释放
  3.闭包，因为闭包会导致内部函数的可访问对象中包含它创建时的作用域中的变量，所以如果不正确使用闭包也会导致内存泄漏
  4.未被移除的事件监听
  5.引用已从dom中移除的元素引用
  -->解决方法：
        1.使用弱引用weakMap，setMap，使用浏览器开发者工具分析内存泄漏来源，确保dom元素被移除时，也移除对它相关的引用。
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
18.页面性能优化？
  1.减少页面的网络请求，尽量使用浏览器缓存或Http缓存，避免不必要的网络请求，或者合并文件
  2.减少页面中的DOM操作，避免浏览器触发重绘和回流
  3.对于页面首次加载不需要的资源，可以采用按需加载，或者给script标签加异步的属性，async或defer
  4.使用打包工具webpack，vite进行代码优化，可以自定义打包行为，压缩代码，减少文件大小
  5.图片可以压缩上传，并选择合适的格式。
  6.避免内存泄露情况出现。
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
19.react和vue的区别？
  1.react使用jsx语法，vue使用模板语法
  2.react是单向数据流，vue也是单向数据流，同时只用v-model支持数据双向绑定
  3.react的生态系统比较好，第三方库很多，vue相对弱一些
  4.react在组件上注重逻辑和结构结合在一起，比如说jsx语法中，我们可以将html结构和js表达式写在一起，在写代码时可以更灵活一些，而vue内部封装了很多模板语法让我们直接使用，使用起来比较方便。
  5.对于数据的变化，react可以在useEffect()钩子中定义，第二个参数接受一个数组，如果是空数组代表组件渲染完后触发一次更新函数，如果不为空数组，则依赖函数会根据数组内的响应式数据是否变化而执行，vue里面有单独定义的生命周期来定义组件从挂载到卸载的过程，也有针对于监听响应式数据的watch()和watchEffect()
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
20.UDP和TCP的区别？
21.防抖和节流怎么实现？
22.盒子水平垂直居中的方式？
23.关于Promise(🌸)
24. css animation transition transform
25.async await
26.TCP四次挥手，三次握手？
27.v-show 和v-if ？
————————————————————————————————————————————————————————————————————————————————————————————————————————————————
28.Vue的双向数据绑定原理？
vue3的双向绑定主要依赖于v-model指令，以及vue的响应式系统实现的
                      ^^^^^^^^^^^      ^^^^^^^^^^^^^
首先：
Vue的响应式系统:vue2是使用Object.defineProperty()方法来实现的，它的缺陷是只能拦截某个对象的某个属性，监听过程中会深度遍历所有这个对象的属性值，
这种方法，如果直接去修改对象的属性(比如添加或删除属性)，(通过数组索引以及数组长度额度改变)并不能检测到.
   --->Vue提供了全局方法来解决:Vue.set()或this.$set
                        ---->用于向响应式对象中添加一个属性，并确保这个新属性石也是响应式的
                        语法：Vue.set(target,propertyName/index,value) 或 this.$set(target,propertyName/index,value)
                          ->target可以是数组或普通对象
                          propertyName/index是要添加的属性名或数组的索引，value是属性的值
                      Vue.delete 或this.$delete [删除]
Vue3使用proxy，它的优点是可以直接拦截整个对象(在不需要递归遍历的情况下实现响应式)
它的思路是拦截一个对象的getter和setter操作，通过WeakMap与Map以及Set这些数据结构，共同维护了一个在代理对象与所要操作的属性，
以及对这个属性要执行的副作用函数(Effect)之间的关系，核心是把对数据的读取或修改操作都变成一个函数来执行，当读取对象的属性时，
就会收集当前的副作用函数到一个effectStack中，修改时从栈中弹出，查找所有这个属性的所依赖的副作用函数并执行，
拦截器的内部使用Reflect上的方法，它的优点在于可以接受第三个参数，相当于一个this，代表是谁在操作
(tip:副作用函数指的是一个执行会直接或间接影响其他函数执行的函数)
---------->Reflect:
              -->Reflect是一个内置对象，它提供拦截 JavaScript 操作的方法(出自MDN)，Reflect提供的方法与Proxy的方法相对应，它让Object操作都变成函数行为
              Reflect.get(target,propertyKey,[receiver])  第一个参数是目标对象 ; 第二个参数是要获取的属性名称 ; 
              第三个是可选参数，如果目标属性是一个getter函数，那么receiver会作为getter调用时的this值
              Reflect.set()同理...
 
Vue创建响应式对象主要是用reactive创建的，他针对于对象类型的数据，因为JavaScript中一切都是对象，
所以不管是对数组还是Set，Map这些数据结构进行任何操作，本质上也是对对象的读取和修改，只是拦截方法不同
-->对于原始值的响应式方案，Vue提供了ref，主要用来让基本数据类型变成响应式数据的，因为proxy只支持代理对象，所以ref内部把所有的基本数据类型外部都包裹了一层对象，
并额外地给它添加了一个属性来标识它是一个ref，以便之后在setup的返回值和模板中脱掉ref。
-->ref解决了响应式丢失的的问题，响应式丢失就是如果我们用reactive来创建一个响应式的对象，然后再把它其中的属性赋值给另外一个普通对象中，
这样响应式就会丢失，因为它不再是原来的对象了，就算属性都是一样的。
在ref中解决了这个问题，因为ref会首先被一个对象包裹，它的属性和与响应式属性同名，值就是getter和setter操作。
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————
29.proxy的优点？
30.数组扁平化
31.react hooks
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
32.进程和线程的区别和联系？
(可以说进程是包含线程的，即线程是进程的子集)
进程： 是运行在系统内存中的程序，每个进程都有自己单独的地址空间
【资源分配的基本单位】
【进程间相互独立，一个进程崩溃后，在保护模式下不会对其他进产生影响】
线程：线程是程序执行的最小单元，它没有自己的地址空间，它可以与同属与一个进程中的其他线程共享进程中的所有资源
【CPU调度的基本单位】
【线程间资源共享，一个线程崩溃可能会影响到同一进程中的其他线程】

--->一个进程可以包含一个或多个线程。
—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
33.进程之间的通信有哪些？
IPC：操作系统的消息，信号，管道，共享内存等机制

--->锁：
在多线程环境下，为了防止不同线程在并发访问共享资源时产生数据不一致的问题，需要使用一种机制来确保任一时刻只有一个线程可以访问特定的资源或代码块(锁)
当一个线程锁定某个资源时，其他试图访问该资源的线程将会被阻塞，直到锁被释放为止。
锁的类型：
1.互斥锁(Mutex):确保同一时刻只有一个线程可以访问共享资源
2.读写锁(ReadWriteLock)：允许多个读操作同时进行，但写操作互斥
3.自旋锁(Soinlock):线程反复检查锁是否可用，而不是等待时睡眠
4.死锁，饥饿...
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
34.为什么浏览器是多进程的？

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
90%(js/css)：
1.JS数据类型？
答：String,Number,Object,BigInt,Symbol,Null,Undefined,Boolean

2.怎么判断JS数据类型？
typeof , instanceof , Object.prototype.toSting.call()

typeof这种方式不能准确判断null，array和object，它们三种返回的结果都是object，而且也不能准确判断NaN， typeof NaN 会返回 Number
instanceof只能判断引用类型的数据，因为它的原理是检测实例对象的原型链上有没有构造函数的prototype属性
Object.prototype.toString.call()方法可以准确判断任何类型

3.数组方法？
Array.prototype.forEach()  返回undefined ，接受一个函数作为参数，会对数组内的每一项元素执行给定方法，不改变原数组
Array.prototype.map(),返回一个新的数组，不改变原数组，新数组的元素是原数组中元素通过给定函数执行后的结果
Array.prototype.filter(),返回一个新数组，不改变原数组，通过指定条件(为true)的元素会被添加到新数组中。
Array.prototype.push()
Array.prototype.pop()
Array.prototype.unshift()  在数组开头添加，返回值是数组的新长度
Array.prototype.shift()   在数组开头移除，返回值为删除元素的值
Array.prototype.reduce() 接受一个函数和一个初始值作为参数，函数的也有两个参数，一个是上一次执行指定函数的结果和当前值，
如果是第一次执行而且传入了初始值，这个值就是指定的值，否则就是数组的第一个元素
Array.prototype.concat() 不改变原数组，返回新数组。合并数组
Array.prototye.find() 接受函数作为参数，返回通过测试的第一个元素，没有通过就返回undefined
Array.prototye.findIndex()  返回满足测试函数的第一个索引，没有返回-1
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
4.H5的新特性？(🌸)
1.利于SEO的语义化标签
<header> <nav> <footer> <section>  <arcticle> <aside>
2.可以在网页中插入视频和音频
<vedio>,<audio>
3.画布和可缩放矢量图形
<canvas>,<svg>
4.web存储
引入localStorage和sessionStorage，indexDB
5.实时通信
WebSockets(提供在客户端和服务器之间进行全双工通信的能力) 和 WebRTC(允许网页应用进行实时视频，音频通讯和数据共享)
6.拖放API
Drag and Drop    https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API/File_drag_and_drop
7.地理定位
Geolocation API   https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation
8.跨文档消息传递
PostMessage API  (跨源通信)
9.表单控件
-->新的输入类型 email color range date等
-->placeholder
-->autocomplete,autofocus,required
10.离线应用
Application Cache(已被Service Workers取代)
Service Workers  https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
5.commonJS和ESmodule的区别 
(commonJS普遍用于服务器端，ES模块一般用在浏览器中，最新版本的NodeJs也可以用ES模块)
1.commonJS使用同步的方式导入模块，在服务器端从磁盘加载非常迅速，但在浏览器端加载新的模块会发起网络请求，等待网络传输，阻塞页面渲染
  ES模块异步加载，(利用script标签加载)
2.commonJS 输出的是对模块的浅拷贝，会运行缓存的结果，一旦输出，模块内的值就算变化也不会被影响到，除非输出的是一个函数
  ES module 是对模块的只读引用，对模块中的值赋值会报错，它不会缓存运行结果，类似于const，内部的指针指向不能改变(ES module充分考虑了静态分析的需求，可以在不执行代码的情况下分析导入导出的结果)
  (ES moudle在编译时静态解析，有利于静态分析工具进行代码优化(tree-shaking))

3.commonJS是运行时加载，而ES module的导入导出语句在js引擎解析脚本时就被确定下来了(即js引擎在执行代码前就知道了模块之间的依赖关系)

es module也支持动态导入 -->import()函数 -->按需加载

因为commonJs时运行时加载，所以在处理循环依赖时可能会有问题，因为模块很有可能在加载时不完整
而es module可以做到按照顺序依次执行循环依赖

【静态分析的优点】
Tree Shaking : 因为模块间的依赖关系在编译时就确定了，打包工具(Webpack,Rollup)可以通过静态分析识别和移除未被使用的代码，减小最终打包文件的大小
按需加载: 静态分析使实现代码分割和按需加载变得简单
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

1.CSS盒模型？
1. border-box ，content-box  [通过box-sizing设置]
border-box的宽和高包括整个盒子的内容，内外编剧与边框
centent-box只计算内容大小
————————————————————————————————————————————————————————————————————————————————————
2.display有哪些属性？
  1.none
  2.inline-block
  3.inline
  4.block
  5.flex
  6.grid
  7.inherit
  8.table
—————————————————————————————————————————————————————————————————————————————————————
3.OSI七层模型？

4.怎么比较浮点数？

5.对象属性的遍历方法？
  1. in 操作符
    可以遍历到对象中的所有属性，无论在原型对象上还是在实例上
  2. for 循环中的 in操作符
    也会返回实例和原型上的属性，而且被实例遮蔽的原型上的属性也会返回
  3.Object.hasOwnProperty()
    用于获取对象原型上的属性
  4.Object.keys()
   获取对象上的所有可枚举属性
  5.Object.getOwnProppertyNames()
   列出所有实例属性，无论是否可枚举(但不包括使用 symbol 值作为名称的属性)
  6.Object.assign()
   静态方法将一个或者多个源对象中所有可枚举的自有属性复制到目标对象，并返回修改后的目标对象
  7.Object.getOwnPropertySymbols()
   静态方法返回一个包含给定对象所有自有 Symbol 属性的数组
——————————————————————————————————————————————————————————————————————————————————————
6.rest参数和arguments对象有什么区别？(rest就是...)
【两者都用于处理函数接受的不确定数量的参数】
  1. arguments是一个类数组对象，它包含了函数调用时传入的所有参数，它只在函数体的内部可用
  2. rest参数将一个不定数量的参数表示为一个数组(它是一个真正的数组，而arguments不是)，只包含没有对应形参的实参，且只能作为函数的最后一个参数出现
【更建议使用rest参数。因为它更灵活】
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
7.http报文有哪些东西？
  首先分为请求报文和响应报文
    ->请求报文： 
            1. 请求行 (包括方法，GET，POST，PUT等，以及请求的URI和HTTP版本) 例：GET/index.html HTTP/1.1
            2. 请求头 (包含请求的元数据，如客户端能接受的内容类型Accept，用户代理User-Agent等)
            3. 空行 (一个空行标识请求头部分的结束和请求体的开始)
            4. 请求体 (可选。包含发送给服务器的数据，不是所有的请求方法都有请求体)
    ->响应报文：
            1.状态行 (包含HTTP版本，状态码和状态消息) 例： HTTP/1.1 200 OK
            2.响应头 (Header:包含响应的元数据，如内容类型Content-type)
            3.空行
            4.响应体 (包含服务器返回的资源内容)
——————————————————————————————————————————————————————————————————————————————————————————————————————————————
8.get请求会被浏览器缓存吗？
  默认会的
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
9.url有长度限制吗？
 -->有长度限制，但是一般限制的长度都远超过实际需求的长度，而且长度的限制页会根据不同的浏览器和服务器的不同而变化
————————————————————————————————————
10.什么是死锁？
11.怎么解决死锁？

12.http 1.0/1.1/2.0/3.0各解决了什么问题？

13.flex有哪些属性？
14.敏感词过滤
15.快速排序
16.非关系型数据库有什么？
17.数据库左连接，右连接区别？
18.vue和react分别是怎么解决样式污染的？
19.TS中的any 和unknown区别？
20.react的useState定义的状态如何确保能拿到最新的值？
21.flex：1 的含义？
22.vue-router两种路由实现方式？
23.React中父组件如何调用子组件的方法？
24.如何定义组件的状态信息(useState()),如果在某个方法中调用了setState改变状态，setState中能获取到最新的值吗？
25.webSocket的心跳检测与重连机制？
26.编写一个executeTasks函数，它接受一个异步任务数组作为参数，每个任务是一个会返回Promise的函数，目的是同时启动这些异步任务，并且在每个任务完成时，
立即按照它们在数组中的原始顺序显示它们的结果？
 const executeTasks = () =>{

 }


















*/
